# Migration Application Guide

## Overview

This guide explains how to apply the consolidated migration cleanup to your Supabase database.

## Prerequisites

- Access to your Supabase project (either via CLI or dashboard)
- `SUPABASE_SERVICE_ROLE_KEY` for admin access
- Basic understanding of SQL

## Option 1: Using Supabase CLI (Recommended)

### 1. Install Supabase CLI

```bash
npm install -g supabase
```

### 2. Link to your project

```bash
supabase link --project-ref YOUR_PROJECT_REF
```

### 3. Apply the migration

```bash
supabase db push
```

## Option 2: Using Supabase Dashboard

### 1. Open SQL Editor

- Go to your Supabase project dashboard
- Navigate to SQL Editor
- Create a new query

### 2. Copy and paste the migration

Copy the contents of `supabase/migrations/20250101000022_consolidated_schema_cleanup.sql` into the SQL editor.

### 3. Execute the migration

Click "Run" to execute all the SQL statements.

## Option 3: Manual Step-by-Step Application

If you prefer to apply the migration manually or encounter issues with the bulk approach:

### Quick view refresh

If your database already contains the `cats` and `skills` tables and you simply need
to add color/order support and rebuild the view, run the following snippet in the SQL editor:

```sql
ALTER TABLE public.cats
  ADD COLUMN IF NOT EXISTS color_hex  text,
  ADD COLUMN IF NOT EXISTS sort_order integer;

ALTER TABLE public.cats
  ALTER COLUMN color_hex SET DEFAULT '#000000';

UPDATE public.cats
   SET sort_order = id
 WHERE sort_order IS NULL;

UPDATE public.cats
   SET color_hex = '#000000'
 WHERE color_hex IS NULL;

DROP VIEW IF EXISTS public.skills_by_cats_v;

CREATE VIEW public.skills_by_cats_v AS
SELECT
    c.id         AS cat_id,
    c.name       AS cat_name,
    c.user_id,
    c.color_hex,
    c.sort_order,
    COUNT(s.id)  AS skill_count,
    COALESCE(
      json_agg(
        json_build_object(
          'id',   s.id,
          'name', s.name,
          'desc', s.description
        ) ORDER BY s.id
      ) FILTER (WHERE s.id IS NOT NULL),
      '[]'
    ) AS skills
FROM public.cats c
LEFT JOIN public.skills s ON s.cat_id = c.id
GROUP BY c.id
ORDER BY c.sort_order NULLS LAST, c.id;
```

### Step 1: Create missing tables

```sql
-- Create cats table
CREATE TABLE IF NOT EXISTS public.cats (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    user_id uuid NOT NULL,
    name text NOT NULL,
    color_hex text DEFAULT '#000000',
    sort_order integer
);

-- Create social_links table
CREATE TABLE IF NOT EXISTS public.social_links (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    user_id uuid NOT NULL,
    platform text NOT NULL,
    url text NOT NULL,
    position integer DEFAULT 0,
    is_active boolean DEFAULT true
);

-- Create content_cards table
CREATE TABLE IF NOT EXISTS public.content_cards (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    user_id uuid NOT NULL,
    title text NOT NULL,
    content text,
    position integer DEFAULT 0,
    is_active boolean DEFAULT true,
    card_type text DEFAULT 'text'
);
```

### Step 2: Add missing columns

```sql
-- Ensure cats table has color/order fields
ALTER TABLE IF EXISTS public.cats
  ADD COLUMN IF NOT EXISTS color_hex text,
  ADD COLUMN IF NOT EXISTS sort_order integer;

ALTER TABLE IF EXISTS public.cats
  ALTER COLUMN color_hex SET DEFAULT '#000000';

UPDATE public.cats
   SET color_hex = '#000000'
 WHERE color_hex IS NULL;

-- Add updated_at columns to existing tables
ALTER TABLE IF EXISTS public.goals ADD COLUMN IF NOT EXISTS updated_at timestamptz NOT NULL DEFAULT now();
ALTER TABLE IF EXISTS public.projects ADD COLUMN IF NOT EXISTS updated_at timestamptz NOT NULL DEFAULT now();
ALTER TABLE IF EXISTS public.tasks ADD COLUMN IF NOT EXISTS updated_at timestamptz NOT NULL DEFAULT now();
ALTER TABLE IF EXISTS public.habits ADD COLUMN IF NOT EXISTS updated_at timestamptz NOT NULL DEFAULT now();
ALTER TABLE IF EXISTS public.skills ADD COLUMN IF NOT EXISTS updated_at timestamptz NOT NULL DEFAULT now();
ALTER TABLE IF EXISTS public.monuments ADD COLUMN IF NOT EXISTS updated_at timestamptz NOT NULL DEFAULT now();
ALTER TABLE IF EXISTS public.profiles ADD COLUMN IF NOT EXISTS updated_at timestamptz NOT NULL DEFAULT now();

-- Add missing profile columns
ALTER TABLE IF EXISTS public.profiles
ADD COLUMN IF NOT EXISTS name text,
ADD COLUMN IF NOT EXISTS dob date,
ADD COLUMN IF NOT EXISTS city text,
ADD COLUMN IF NOT EXISTS bio text,
  ADD COLUMN IF NOT EXISTS avatar_url text;
```

### Step 3: Create triggers and functions

```sql
-- Create updated_at trigger function
CREATE OR REPLACE FUNCTION public.set_updated_at()
RETURNS trigger LANGUAGE plpgsql AS $$
BEGIN
  NEW.updated_at = now();
  RETURN NEW;
END
$$;

-- Add updated_at triggers
CREATE TRIGGER IF NOT EXISTS goals_set_updated_at BEFORE UPDATE ON public.goals FOR EACH ROW EXECUTE FUNCTION public.set_updated_at();
CREATE TRIGGER IF NOT EXISTS projects_set_updated_at BEFORE UPDATE ON public.projects FOR EACH ROW EXECUTE FUNCTION public.set_updated_at();
CREATE TRIGGER IF NOT EXISTS tasks_set_updated_at BEFORE UPDATE ON public.tasks FOR EACH ROW EXECUTE FUNCTION public.set_updated_at();
CREATE TRIGGER IF NOT EXISTS habits_set_updated_at BEFORE UPDATE ON public.habits FOR EACH ROW EXECUTE FUNCTION public.set_updated_at();
CREATE TRIGGER IF NOT EXISTS skills_set_updated_at BEFORE UPDATE ON public.skills FOR EACH ROW EXECUTE FUNCTION public.set_updated_at();
CREATE TRIGGER IF NOT EXISTS monuments_set_updated_at BEFORE UPDATE ON public.monuments FOR EACH ROW EXECUTE FUNCTION public.set_updated_at();
CREATE TRIGGER IF NOT EXISTS profiles_set_updated_at BEFORE UPDATE ON public.profiles FOR EACH ROW EXECUTE FUNCTION public.set_updated_at();
CREATE TRIGGER IF NOT EXISTS social_links_set_updated_at BEFORE UPDATE ON public.social_links FOR EACH ROW EXECUTE FUNCTION public.set_updated_at();
CREATE TRIGGER IF NOT EXISTS content_cards_set_updated_at BEFORE UPDATE ON public.content_cards FOR EACH ROW EXECUTE FUNCTION public.set_updated_at();
```

### Step 4: Create views

```sql
-- Create skills_by_cats_v view
DROP VIEW IF EXISTS public.skills_by_cats_v CASCADE;
CREATE VIEW public.skills_by_cats_v AS
SELECT
    c.id as cat_id,
    c.name as cat_name,
    c.user_id,
    c.color_hex,
    c.sort_order,
    COUNT(s.id) as skill_count,
    COALESCE(
        json_agg(
            json_build_object(
                'id', s.id,
                'title', s.title,
                'user_id', s.user_id,
                'created_at', s.created_at,
                'updated_at', s.updated_at
            ) ORDER BY s.created_at DESC
        ) FILTER (WHERE s.id IS NOT NULL),
        '[]'::json
    ) as skills
FROM public.cats c
LEFT JOIN public.skills s ON c.id = s.cat_id AND c.user_id = s.user_id
GROUP BY c.id, c.name, c.user_id, c.color_hex, c.sort_order
ORDER BY c.sort_order NULLS LAST, c.name;
```

### Step 5: Enable RLS and create policies

```sql
-- Enable RLS
ALTER TABLE public.cats ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.social_links ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.content_cards ENABLE ROW LEVEL SECURITY;

-- Create RLS policies (see the full migration file for complete policies)
-- This is a simplified version - refer to the full migration for all policies
```

### Step 6: Create indexes and grant permissions

```sql
-- Create indexes
CREATE INDEX IF NOT EXISTS cats_user_id_idx ON public.cats(user_id);
CREATE INDEX IF NOT EXISTS social_links_user_id_idx ON public.social_links(user_id);
CREATE INDEX IF NOT EXISTS content_cards_user_id_idx ON public.content_cards(user_id);

-- Grant permissions
GRANT ALL ON public.cats TO authenticated;
GRANT ALL ON public.social_links TO authenticated;
GRANT ALL ON public.content_cards TO authenticated;
GRANT SELECT ON public.skills_by_cats_v TO authenticated;
```

## Verification

After applying the migration, verify that:

1. **Tables exist**: `cats`, `social_links`, `content_cards`
2. **Columns exist**: `updated_at` on all major tables, profile fields
3. **Views exist**: `skills_by_cats_v`
4. **Triggers work**: Update a record and check if `updated_at` changes

## Troubleshooting

### Common Issues

1. **Permission denied**: Ensure you're using the service role key
2. **Table already exists**: The migration uses `IF NOT EXISTS` so this shouldn't be an issue
3. **Column already exists**: The migration uses `ADD COLUMN IF NOT EXISTS`
4. **Trigger already exists**: The migration checks for existing triggers

### Rollback

If something goes wrong, you can rollback by:

1. Dropping the new tables: `DROP TABLE IF EXISTS cats, social_links, content_cards CASCADE;`
2. Dropping the view: `DROP VIEW IF EXISTS skills_by_cats_v CASCADE;`
3. Removing added columns: `ALTER TABLE profiles DROP COLUMN IF EXISTS name, dob, city, bio, avatar_url;`

## Next Steps

After successful migration:

1. Test your application to ensure all features work
2. Check that existing data is properly categorized
3. Monitor performance with the new indexes
4. Consider creating a backup of your current working state
