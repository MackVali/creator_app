# Migration Application Guide

## Overview

This guide explains how to apply the consolidated migration cleanup to your Supabase database.

## Prerequisites

- Access to your Supabase project (either via CLI or dashboard)
- `SUPABASE_SERVICE_ROLE_KEY` for admin access
- Basic understanding of SQL

## Option 1: Using Supabase CLI (Recommended)

### 1. Install Supabase CLI

```bash
npm install -g supabase
```

### 2. Link to your project

```bash
supabase link --project-ref YOUR_PROJECT_REF
```

### 3. Apply the migration

```bash
supabase db push
```

## Option 2: Using Supabase Dashboard

### 1. Open SQL Editor

- Go to your Supabase project dashboard
- Navigate to SQL Editor
- Create a new query

### 2. Copy and paste the migration

Copy the contents of `supabase/migrations/20250101000022_consolidated_schema_cleanup.sql` into the SQL editor.

### 3. Execute the migration

Click "Run" to execute all the SQL statements.

## Post-migration verification

Once the SQL completes successfully (either via CLI or dashboard), double-check that the application layers recognize the new
`HABIT` source type:

1. Regenerate Supabase types so the client code picks up the enum change. If you use `supabase gen types typescript`, re-run it
   and commit the updated `types/supabase.ts` file.
2. Restart local development servers (Next.js, vitest watchers, etc.) so they reload the refreshed type definitions.
3. Run the scheduler test suite to ensure habit instances now persist end-to-end:

   ```bash
   pnpm test:run test/lib/scheduler/*.spec.ts
   ```

   If you prefer, `pnpm test` without arguments will execute the full Vitest suite, including the scheduler specs.
4. Trigger a manual scheduler run (e.g., `POST /api/scheduler/run`) and confirm newly scheduled habits now appear in
   `public.schedule_instances` with `source_type = 'HABIT'` and no overlapping time ranges for non-sync habits.

These steps keep the database, generated types, and runtime cache in sync after the enum addition.

## Option 3: Manual Step-by-Step Application

If you prefer to apply the migration manually or encounter issues with the bulk approach:

### Step 1: Create missing tables

```sql
-- Create cats table
CREATE TABLE IF NOT EXISTS public.cats (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    user_id uuid NOT NULL,
    name text NOT NULL
);

-- Create social_links table
CREATE TABLE IF NOT EXISTS public.social_links (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    user_id uuid NOT NULL,
    platform text NOT NULL,
    url text NOT NULL,
    position integer DEFAULT 0,
    is_active boolean DEFAULT true
);

-- Create content_cards table
CREATE TABLE IF NOT EXISTS public.content_cards (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    user_id uuid NOT NULL,
    title text NOT NULL,
    content text,
    position integer DEFAULT 0,
    is_active boolean DEFAULT true,
    card_type text DEFAULT 'text'
);
```

### Step 2: Add missing columns

```sql
-- Add updated_at columns to existing tables
ALTER TABLE IF EXISTS public.goals ADD COLUMN IF NOT EXISTS updated_at timestamptz NOT NULL DEFAULT now();
ALTER TABLE IF EXISTS public.projects ADD COLUMN IF NOT EXISTS updated_at timestamptz NOT NULL DEFAULT now();
ALTER TABLE IF EXISTS public.tasks ADD COLUMN IF NOT EXISTS updated_at timestamptz NOT NULL DEFAULT now();
ALTER TABLE IF EXISTS public.habits ADD COLUMN IF NOT EXISTS updated_at timestamptz NOT NULL DEFAULT now();
ALTER TABLE IF EXISTS public.skills ADD COLUMN IF NOT EXISTS updated_at timestamptz NOT NULL DEFAULT now();
ALTER TABLE IF EXISTS public.monuments ADD COLUMN IF NOT EXISTS updated_at timestamptz NOT NULL DEFAULT now();
ALTER TABLE IF EXISTS public.profiles ADD COLUMN IF NOT EXISTS updated_at timestamptz NOT NULL DEFAULT now();

-- Add missing profile columns
ALTER TABLE IF EXISTS public.profiles
ADD COLUMN IF NOT EXISTS name text,
ADD COLUMN IF NOT EXISTS dob date,
ADD COLUMN IF NOT EXISTS city text,
ADD COLUMN IF NOT EXISTS bio text,
ADD COLUMN IF NOT EXISTS avatar_url text;
```

### Step 3: Create triggers and functions

```sql
-- Create updated_at trigger function
CREATE OR REPLACE FUNCTION public.set_updated_at()
RETURNS trigger LANGUAGE plpgsql AS $$
BEGIN
  NEW.updated_at = now();
  RETURN NEW;
END
$$;

-- Add updated_at triggers
CREATE TRIGGER IF NOT EXISTS goals_set_updated_at BEFORE UPDATE ON public.goals FOR EACH ROW EXECUTE FUNCTION public.set_updated_at();
CREATE TRIGGER IF NOT EXISTS projects_set_updated_at BEFORE UPDATE ON public.projects FOR EACH ROW EXECUTE FUNCTION public.set_updated_at();
CREATE TRIGGER IF NOT EXISTS tasks_set_updated_at BEFORE UPDATE ON public.tasks FOR EACH ROW EXECUTE FUNCTION public.set_updated_at();
CREATE TRIGGER IF NOT EXISTS habits_set_updated_at BEFORE UPDATE ON public.habits FOR EACH ROW EXECUTE FUNCTION public.set_updated_at();
CREATE TRIGGER IF NOT EXISTS skills_set_updated_at BEFORE UPDATE ON public.skills FOR EACH ROW EXECUTE FUNCTION public.set_updated_at();
CREATE TRIGGER IF NOT EXISTS monuments_set_updated_at BEFORE UPDATE ON public.monuments FOR EACH ROW EXECUTE FUNCTION public.set_updated_at();
CREATE TRIGGER IF NOT EXISTS profiles_set_updated_at BEFORE UPDATE ON public.profiles FOR EACH ROW EXECUTE FUNCTION public.set_updated_at();
CREATE TRIGGER IF NOT EXISTS social_links_set_updated_at BEFORE UPDATE ON public.social_links FOR EACH ROW EXECUTE FUNCTION public.set_updated_at();
CREATE TRIGGER IF NOT EXISTS content_cards_set_updated_at BEFORE UPDATE ON public.content_cards FOR EACH ROW EXECUTE FUNCTION public.set_updated_at();
```

### Step 4: Create views

```sql
-- Create skills_by_cats_v view
DROP VIEW IF EXISTS public.skills_by_cats_v CASCADE;
CREATE VIEW public.skills_by_cats_v AS
SELECT
    c.id as cat_id,
    c.name as cat_name,
    c.user_id,
    COUNT(s.id) as skill_count,
    COALESCE(
        json_agg(
            json_build_object(
                'id', s.id,
                'title', s.title,
                'user_id', s.user_id,
                'created_at', s.created_at,
                'updated_at', s.updated_at
            ) ORDER BY s.created_at DESC
        ) FILTER (WHERE s.id IS NOT NULL),
        '[]'::json
    ) as skills
FROM public.cats c
LEFT JOIN public.skills s ON c.id = s.cat_id AND c.user_id = s.user_id
GROUP BY c.id, c.name, c.user_id
ORDER BY c.name;
```

### Step 5: Enable RLS and create policies

```sql
-- Enable RLS
ALTER TABLE public.cats ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.social_links ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.content_cards ENABLE ROW LEVEL SECURITY;

-- Create RLS policies (see the full migration file for complete policies)
-- This is a simplified version - refer to the full migration for all policies
```

### Step 6: Create indexes and grant permissions

```sql
-- Create indexes
CREATE INDEX IF NOT EXISTS cats_user_id_idx ON public.cats(user_id);
CREATE INDEX IF NOT EXISTS social_links_user_id_idx ON public.social_links(user_id);
CREATE INDEX IF NOT EXISTS content_cards_user_id_idx ON public.content_cards(user_id);

-- Grant permissions
GRANT ALL ON public.cats TO authenticated;
GRANT ALL ON public.social_links TO authenticated;
GRANT ALL ON public.content_cards TO authenticated;
GRANT SELECT ON public.skills_by_cats_v TO authenticated;
```

## Verification

After applying the migration, verify that:

1. **Tables exist**: `cats`, `social_links`, `content_cards`
2. **Columns exist**: `updated_at` on all major tables, profile fields
3. **Views exist**: `skills_by_cats_v`
4. **Triggers work**: Update a record and check if `updated_at` changes

## Troubleshooting

### Common Issues

1. **Permission denied**: Ensure you're using the service role key
2. **Table already exists**: The migration uses `IF NOT EXISTS` so this shouldn't be an issue
3. **Column already exists**: The migration uses `ADD COLUMN IF NOT EXISTS`
4. **Trigger already exists**: The migration checks for existing triggers

### Rollback

If something goes wrong, you can rollback by:

1. Dropping the new tables: `DROP TABLE IF EXISTS cats, social_links, content_cards CASCADE;`
2. Dropping the view: `DROP VIEW IF EXISTS skills_by_cats_v CASCADE;`
3. Removing added columns: `ALTER TABLE profiles DROP COLUMN IF EXISTS name, dob, city, bio, avatar_url;`

## Next Steps

After successful migration:

1. Test your application to ensure all features work
2. Check that existing data is properly categorized
3. Monitor performance with the new indexes
4. Consider creating a backup of your current working state
