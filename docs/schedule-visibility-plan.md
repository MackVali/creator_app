# Plan: Restore Visibility of Schedule Instances

## 1. Reproduce and Measure
- [ ] Add a temporary Vitest covering `fetchInstancesForRange` to assert that rows with `status = null` are preserved while canceled rows are skipped.
- [ ] Use the Supabase SQL editor (or local seed data) to snapshot the actual `status` values stored for recent instances to confirm assumptions about casing and nullability.
- [ ] Log the raw response inside the scheduler edge function when running in staging to verify that the API still returns rows before in-memory filtering happens.

## 2. Narrow Down Regression
- [ ] Compare the SQL generated by the current `or(...)` clause with the pre-regression query (`.neq('status', 'canceled')`) to see whether it stopped using the `schedule_instances_status_idx` index.
- [ ] Inspect the PostgREST response metadata for pagination hints (e.g., `Content-Range`) to detect whether filtering client-side is hiding the fact that the API now returns 0 rows.
- [ ] Confirm that the edge function deploy still uses the same Supabase client versionâ€”an older runtime may not support the spread-based response cloning we introduced.

## 3. Implement Fix
- [ ] Replace the client-side filtering with a PostgREST-compatible filter such as `.or('status.is.null,status.eq.scheduled,status.eq.confirmed')` so the database handles visibility.
- [ ] Ensure every call path (web app + edge function) applies the same filter helper to avoid drift.
- [ ] Backfill tests to cover the mixed status set (null, canceled, confirmed) so future refactors keep the regression from returning.

## 4. Verify End-to-End
- [ ] Run the new Vitest suite locally.
- [ ] Trigger the scheduler edge function in staging and confirm upcoming slots render in the UI.
- [ ] Remove temporary logging once visibility is restored.
